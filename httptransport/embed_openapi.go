// +build tools

// Embed_openapi is a script to take the OpenAPI YAML file, turn it into a JSON
// document, and embed it into a source file for easy deployment.
package main

import (
	"crypto/sha256"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"os"
	"text/template"

	"gopkg.in/yaml.v2"
)

type genInput struct {
	Pkg      string
	Name     string
	Embed    string
	Checksum []byte
}

const genTmpl = ` // Code generated by embed_openapi.go, DO NOT EDIT.

package {{.Pkg}}

const (
	{{.Name}} = ` + "`{{.Embed}}`" + `
	{{.Name}}Etag = ` + "`\"{{printf \"%x\" .Checksum}}\"`" + `
)
`

func main() {
	pkgName := flag.String("pkg", "httptransport", "package name of generated file")
	constName := flag.String("name", "_openapiJSON", "name used for the constant")
	inFile := flag.String("in", "../openapi.yaml", "input YAML file")
	outFile := flag.String("out", "discoveryhandler_gen.go", "output go file")
	flag.Parse()

	inF, err := os.Open(*inFile)
	if err != nil {
		log.Fatal(err)
	}
	defer inF.Close()
	tmp := map[interface{}]interface{}{}
	if err := yaml.NewDecoder(inF).Decode(&tmp); err != nil {
		log.Fatal(err)
	}

	tmpl, err := template.New("output").Parse(genTmpl)
	if err != nil {
		log.Fatal(err)
	}

	embed, err := json.Marshal(convert(tmp))
	if err != nil {
		log.Fatal(err)
	}

	outF, err := os.OpenFile(*outFile, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, 0644)
	if err != nil {
		log.Fatal(err)
	}
	defer outF.Close()
	ck := sha256.Sum256(embed)
	if err := tmpl.Execute(outF, &genInput{
		Pkg:      *pkgName,
		Name:     *constName,
		Embed:    string(embed),
		Checksum: ck[:],
	}); err != nil {
		log.Fatal(err)
	}
}

// Convert yoinked from:
// https://stackoverflow.com/questions/40737122/convert-yaml-to-json-without-struct/40737676#40737676
func convert(i interface{}) interface{} {
	switch x := i.(type) {
	case map[interface{}]interface{}:
		m2 := map[string]interface{}{}
		for k, v := range x {
			m2[fmt.Sprint(k)] = convert(v)
		}
		return m2
	case []interface{}:
		for i, v := range x {
			x[i] = convert(v)
		}
	}
	return i
}
